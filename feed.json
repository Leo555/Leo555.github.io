{"title":"lizhen's blog","description":"Lizhen's personal static blog.","language":"","link":"https://lz5z.com","pubDate":"Thu, 31 Jan 2019 19:52:19 GMT","lastBuildDate":"Tue, 21 Apr 2020 10:25:03 GMT","generator":"hexo-generator-json-feed","webMaster":"lizhen","items":[{"title":"[真] Node多线程","link":"https://lz5z.com/真-Node多线程/","description":"本文测试使用环境： 系统：macOS Mojave 10.14.2 CPU：4 核 2.3 GHz Node: 10.15.1 从 Node 线程说起 一般人理解 Node 是单线程的，所以 Node 启动后线程数应该为 1，我们做实验看一下。 123setInterval(() =&gt; &#123; console.log(new Date().getTime())&#125;, 3000) 可以看到 Node 进程占用了 7 个线程。为什么会有 7 个线程呢？ 我们都知道，Node 中最核心的是 v8 引擎，在 Node 启动后，会创建 v8 的实例，这个实例是多线程的。 主线程：编译、执行代码。 编译/优化线程：在主线程执行的时候，可以优化代码。 分析器线程：记录分析代码运行时间，为 Crankshaft 优化代码执行提供依据。 垃圾回收的几个线程。","pubDate":"Thu, 31 Jan 2019 19:52:19 GMT","guid":"https://lz5z.com/真-Node多线程/","category":"Node"},{"title":"React Hooks 是什么","link":"https://lz5z.com/React-Hooks/","description":"最近在重构 BadJS 的管理页面，使用 TypeScript + React Hooks 的技术栈，趁这个机会好好理一理 React Hooks 那些事儿。 React Hooks 是 16.7.0-alpha 版本的新特性，安装即可享用。 React Hooks 简介 React Hooks 是对 React function 组件的一种扩展，通过一些特殊的函数，让无状态组件拥有状态组件才拥有的能力。 Hooks 是 React 函数组件中的一类特殊函数，通常以 use 开头，比如 useRef，useState，useReducer 等。通常在我们写 React 组件的时候，如果这个组件比较复杂，拥有自己的生命周期或者 state，就将其写成 class 组件；如果这个组件仅仅用来展示，就将其写成 function 组件。 React Hooks 使用 function 组件的写法，通过 useState 这样的 API 解决了 function 组件没有 state 的问题，通过 useEffect 来解决生命周期的问题，通过自定义 hooks 来复用业务逻辑。 Hooks 解决哪些问题 复用与状态有关的逻辑，之前引申出来 HOC 的概念，但是 HOC 会导致组件树的臃肿。 解决组件随着业务扩展变得难以维护的问题。 使用更容易理解并且对初学者更友好的 function 组件。","pubDate":"Mon, 07 Jan 2019 22:34:24 GMT","guid":"https://lz5z.com/React-Hooks/","category":"React"},{"title":"Koa 源码研读","link":"https://lz5z.com/Koa-Source/","description":"简介 Koa 是一个非常轻量的 web 开发框架，由 Express 团队打造。相较于 Express，Koa 使用 async 函数解决异步的问题，并且完全脱离中间件，非常优雅，而且 Koa 代码简洁友好，很适合初学者阅读。 Koa 代码结构","pubDate":"Wed, 05 Dec 2018 23:06:57 GMT","guid":"https://lz5z.com/Koa-Source/","category":"JavaScript"},{"title":"使用 SRI 解决 CDN 劫持","link":"https://lz5z.com/SRI-CDN/","description":"SRI 简介 SRI 全称 Subresource Integrity - 子资源完整性，是指浏览器通过验证资源的完整性（通常从 CDN 获取）来判断其是否被篡改的安全特性。 通过给 link 标签或者 script 标签增加 integrity 属性即可开启 SRI 功能，比如： 1&lt;script type=\"text/javascript\" src=\"//s.url.cn/xxxx/xxx.js?_offline=1\" integrity=\"sha256-mY9nzNMPPf8oL3CJss7THIEoXAC2ToW1tEX0NBhMvuw= sha384-ncIKElSEk2OR3YfjNLRSY35mzt0CUwrpNDVS//iD3dF9vxrWeZ7WPlAPJTqGkSai\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; integrity 值分成两个部分，第一部分指定哈希值的生成算法（sha256、sha384 及 sha512），第二部分是经过 base64 编码的实际哈希值，两者之间通过一个短横（-）分割。integrity 值可以包含多个由空格分隔的哈希值，只要文件匹配其中任意一个哈希值，就可以通过校验并加载该资源。上述例子中我使用了 sha256 和 sha384 两张 hash 方案。","pubDate":"Sun, 25 Nov 2018 13:05:48 GMT","guid":"https://lz5z.com/SRI-CDN/","category":"HTML"},{"title":"API 网关 Kong","link":"https://lz5z.com/API-Gateway-Kong/","description":"Kong 简介 Kong 是一款基于 OpenResty 的 API 网关平台，在客户端和（微）服务之间转发 API 通信。Kong 通过插件的方式扩展自己的功能，其中包括身份验证、安全控制、流量控制、熔断机制、日志、黑名单、API 分发等等众多功能。下图是官网给出的传统项目架构和使用 Kong 的架构： Next-Generation API Platform for Modern Architectures。","pubDate":"Wed, 24 Oct 2018 21:51:14 GMT","guid":"https://lz5z.com/API-Gateway-Kong/","category":"网络"},{"title":"使用 requestAnimationFrame 解决滚动点停误触和 scroll 事件延迟","link":"https://lz5z.com/requestAnimationFrame_to_solve_scroll_event_late/","description":"背景 在手机端网页开发过程中，我们经常会遇到滚动点停误触的问题，最开始想到的解决办法就是判断当前页面（DOM）是否在滚动，如果在滚动，就取消点击或者其他事件。但是在判断页面是否在滚动的时候出现了一些问题，最常见的就 uiwebview scroll 事件延迟，导致我们无法准确判断当前页面（DOM）是否还在滚动。于是想到了使用 requestAnimationFrame 判断某个元素的位置是否发生变化来标识当前页面（DOM）是否在滚动。","pubDate":"Tue, 09 Oct 2018 13:07:37 GMT","guid":"https://lz5z.com/requestAnimationFrame_to_solve_scroll_event_late/","category":"JavaScript"},{"title":"webpack4 新特性","link":"https://lz5z.com/webpack4-new/","description":"wepack4 出来已经有半年了，目前最新的 release 版本为 4.19.0。由于之前项目打包一直存在性能问题，所以我一直很关注 webpack 和其社区的发展。目前来说 webpack4 已经趋于稳定，很多关键的插件也都更新了对 webpack4 的支持；更为重要的是，webpack4 的官方文档（中英文）已经很完善了，因此现在不学习 webpack4，更待何时。根据 webpack 作者 Tobias Koppers 的说法，他们已经着手开始开发 webpack5 了。 关于 webpack 入门的文章可以参考 webpack 从入门到放弃。 关于 webpack 性能优化的内容可以参考 webpack 打包优化。 关于 webpack4 全部新的特性可以查看官方的 releases。","pubDate":"Sat, 15 Sep 2018 17:13:58 GMT","guid":"https://lz5z.com/webpack4-new/","category":"JavaScript"},{"title":"再见金山，你好腾讯","link":"https://lz5z.com/GoodByeKingsoft-HelloTencent/","description":"有什么感受 在金山的最后一天了，从昨天早上就开始了划水摸鱼的工作模式，主要是把项目的代码结构给几位同事讲一下，还有一些比较容易让人困惑的点，才发现我对项目是如此熟悉，大部分代码如数家珍。 从 2017 年 2 月 14 号情人节入职到明天 2018 年 8 月 24 正式离职，差不多在这里呆了一年半的时间，自己的进步自己看得到，周围的同事也看得到。老大曾经对我说，感觉入职的时候对我的评级评低了。听到以后很开心，可能不是评低了，是我确实进步了不少。跟去年要离开 OOCL 的时候感觉不同，那个时候正好赶上过年并且自己做的项目没有东西可以做，所以非常轻松，走之前差不多很长一段时间都在摸鱼。而这次从金山离职，从提出离职申请到昨天，基本上每天都有事情要做，赶需求，改 Bug，招新人，讲代码，交接功能，一直忙个不停。可见自己的重要性提高了，所以非常谨慎地又将一些可能留下的问题改了又改，争取不给后面的同事埋坑。","pubDate":"Fri, 24 Aug 2018 10:25:35 GMT","guid":"https://lz5z.com/GoodByeKingsoft-HelloTencent/","category":"Work"},{"title":"Symbol","link":"https://lz5z.com/JavaScript-Symbol/","description":"ES2018新特性学习 中又回顾到了 symbol 数据类型。Symbol 作为一种原始数据类型，除了其 Symbol.iterator 属性和 Symbol.asyncIterator 属性为数据提供 for...of 和 for...await...of 访问机制外，它还有什么功能呢？或者说，ES6 中增加 Symbol 数据类型主要面对什么场景呢？ Symbol 简介 Symbol() 函数返回 symbol 类型的值，该类型具有静态属性和静态方法，并且不支持 new Symbol() 语法。每个从 Symbol() 函数中返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符，这是该数据类型最大的目的。","pubDate":"Mon, 09 Jul 2018 21:31:49 GMT","guid":"https://lz5z.com/JavaScript-Symbol/","category":"JavaScript"},{"title":"HTTP 协议 Transfer-Encoding","link":"https://lz5z.com/HTTP-Transfer-Encoding/","description":"简介 Transfer-Encoding (传输编码) 是常见的 HTTP 头 字段，表示将实体安全传递给用户所采用的编码形式。与另外一个更为常见的 Content-Encoding 不同，Content-Encoding 表示内容编码，通常用于对实体内容进行压缩编码，比如 gzip，deflate 等。而 Transfer-Encoding 不会减少实体内容传输大小，但是会改变实体传输的形式。Content-Encoding 和 Transfer-Encoding 二者是相辅相成的，对于一个 HTTP 报文，很可能同时进行了内容编码和传输编码。 在 HTTP 请求头中，Transfer-Encoding 被称为 TE，表示浏览器预期接受的传输编码方式，可使用 Response 头 Transfer-Encoding 字段中的值，比如 chunked；另外还可用 trailers 这个值来表明浏览器希望在最后一个大小为 0 的块之后还接收到一些额外的字段。","pubDate":"Mon, 09 Jul 2018 00:08:27 GMT","guid":"https://lz5z.com/HTTP-Transfer-Encoding/","category":"网络"},{"title":"HTTP 状态码 301 与 302 的区别","link":"https://lz5z.com/HTTP-301-vs-302/","description":"301 和 302 有啥区别 301 Moved Permanently，永久重定向。被请求资源已永久移动到新位置，并且将来任何对该资源的引用都使用本响应返回的若干个 URI 之一。301 资源除非额外指定，否则都是可缓存的。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个 301 响应的话，接下来的重定向请求将会变成 GET 方式。 302 Found 表示临时重定向 Moved Temporarily。由于这样的重定向是临时的，客户端应继续向原有地址发送以后的请求，只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。 注意：虽然 RFC1945 和 RFC 2068 规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将 302 响应视作为 303 响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。因此状态码 303 和 307 被添加了进来，用以明确服务器期待客户端进行何种反应。","pubDate":"Sun, 08 Jul 2018 20:28:56 GMT","guid":"https://lz5z.com/HTTP-301-vs-302/","category":"网络"},{"title":"ES2018新特性学习","link":"https://lz5z.com/ES2018新特性学习/","description":"ECMAScript 2018 (ES9) 在 6 月底正式发布，带来了很多新特性。关于 ES7 和 ES8 相关的知识，可以查看这篇文章 ES2016 和 ES2017 学习。目前大部分 ES7 和 ES8 的特性都得到主流浏览器的支持，而 ES9 的新特性还未能实现很好的兼容性。 关于 ES7/8/9 全部特性可以查看 tc39 官方的 proposals，这些都是最后进入 stage 4 的特性。 ES9 的新特性： Lifting template literal restriction 模板语法修正 s (dotAll) flag for regular expressions (正则表达式 dotAll 模式) RegExp named capture groups (正则表达式命名捕获组) Rest/Spread Properties (Rest/Spread 属性) RegExp Lookbehind Assertions (正则表达式反向(lookbehind)断言) RegExp Unicode Property Escapes (正则表达式 Unicode 转义) Promise.prototype.finally Asynchronous Iteration (异步迭代器)","pubDate":"Mon, 02 Jul 2018 19:47:59 GMT","guid":"https://lz5z.com/ES2018新特性学习/","category":"JavaScript"},{"title":"《深入浅出Node.js》-玩转进程","link":"https://lz5z.com/深入浅出Node-js-玩转进程/","description":"第九章 玩转进程 Node 基于 V8 引擎构建，采用单线程模型，所有的 JavaScript 将会运行在单个进程的单个线程上，它带来的好处是：没有多线程中常见的锁以及线程同步的问题，操作系统在调度时也能减少上下文切换，提高 CPU 使用率。但是如今 CPU 基本均是多核的，真正的服务器往往还有多个 CPU，一个 Node 进程只能利用一个核，这带来硬件资源的浪费。另外，Node 运行在单线程之上，一个单线程抛出异常而没有被捕获，将会导致进程的崩溃。 严格来说，Node 并非真正的单线程，Node 自身中还有 I/O 线程存在，这些 I/O 线程由底层 libuv 处理，这部分线程对于 JavaScript 而言是透明的，只有 C++ 扩展时才会关注到，JavaScript 代码运行在 V8 上，是单线程的。","pubDate":"Mon, 18 Jun 2018 17:28:28 GMT","guid":"https://lz5z.com/深入浅出Node-js-玩转进程/","category":"Node"},{"title":"《深入浅出Node.js》-WebSocket","link":"https://lz5z.com/深入浅出Node-js-WebSocket/","description":"构建 WebSocket 服务 WebSocket 与 Node 之间的配合可以说是天作之合：WebSocket 客户端基于事件的编程模型与 Node 中自定义事件相差无几；WebSocket 实现了客户端与服务器之间的长连接，而 Node 在与大量客户端之间保持高并发连接方面非常擅长。 WebSocket 有以下好处： 客户端与服务器之间只需要建立一个 TCP 连接，可以使用更少的连接。 WebSocket 服务器可以推送数据到客户端，比 HTTP 请求响应模型更灵活。 WebSocket 协议头更加轻量，减少数据传输。 WebSocket 既可以发送文本，也可以发送二进制数据。 WebSocket 没有同源限制，客户端可以与任意服务器通信。 建立在 TCP 协议之上，与 HTTP 协议有很好的兼容性，默认端口也是 80 和 443。","pubDate":"Fri, 08 Jun 2018 11:58:26 GMT","guid":"https://lz5z.com/深入浅出Node-js-WebSocket/","category":"Node"},{"title":"《深入浅出Node.js》-网络编程","link":"https://lz5z.com/深入浅出Node-js-网络编程/","description":"第七章 网络编程 Node 中提供了 net，dgram，http，https 四个模块，分别用来处理 TCP，UDP，HTTP，HTTPS，适用于客户端和服务器。 TCP TCP 传输控制协议，在 OSI 模型中属于传输层，许多应用层的协议基于 TCP 构建，比如 HTTP，SMTP，IMAP 等。回顾一下 OSI 模型。 第 7 层：应用层为操作系统或网络应用程序提供访问网络服务的接口。应用层协议的代表包括： HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等。 第 6 层：表示层把数据转换为接受者能够兼容并且适合传输的内容，比如数据加密，压缩，格式转换等。 第 5 层：会话层负责数据传输中设置和维持网络设备之间的通信连接。管理主机之间的会话进程，还可以利用在数据中插入校验点来实现数据的同步。 第 4 层：传输层把传输表头加至数据形成数据包，完成端到端的数据传输。传输表头包含了协议等信息，比如: TCP，UDP 等。 第 3 层：网络层负责对子网间的数据包进行寻址和路由选择，还可以实现拥塞控制，网际互联等功能。网络层的协议包括：IP，IPX 等。 第 2 层：数据链路层在不可靠的物理介质上提供可靠的传输，主要主要为：物理地址寻址、数据封装成帧、流量控制、数据校验、重发等。 第 1 层：物理层在局域网上传送数据帧，负责电脑通信设备与网络媒体之间的互通，包括针脚，电压，线缆规范，集线器，网卡，主机适配等。","pubDate":"Wed, 30 May 2018 00:12:53 GMT","guid":"https://lz5z.com/深入浅出Node-js-网络编程/","category":"Node"},{"title":"《深入浅出Node.js》-理解Buffer","link":"https://lz5z.com/深入浅出Node-js-理解Buffer/","description":"第六章 理解 Buffer Buffer 结构 Buffer 是一个像 Array 的对象，主要用来操作字节。Buffer 是一个典型的 JavaScript 与 C++ 结合的模块，它将性能相关的部分用 C++ 实现，将非性能相关的部分用 JavaScript 实现。 Buffer 所占用的内存不是通过 V8 分配的，而是堆外内存。由于 V8 垃圾回收性能的影响，将 Buffer 对象用更高效的专有内存分配回收策略来管理。 Buffer 在 Node 进程启动的时候已经载入了，并将其放在全局对象 global 上，因此无需 require() 就能使用。 Buffer 对象 Buffer 的元素为 16 进制的两位数，即 0 到 255 的数值。 123var str = '深入浅出node.js'var buf = new Buffer(str, 'utf8')console.log(buf) // &lt;Buffer e6 b7 b1 e5 85 a5 e6 b5 85 e5 87 ba 6e 6f 64 65 2e 6a 73&gt; 不同编码的字符串占用的元素个数各不相同，中文在 UTF-8 编码下占用 3 个元素，字母和半角标点占用 1 个元素。 Buffer 可以通过 length 属性得到长度，也可以通过下标访问元素。","pubDate":"Mon, 28 May 2018 22:11:29 GMT","guid":"https://lz5z.com/深入浅出Node-js-理解Buffer/","category":"Node"},{"title":"《深入浅出Node.js》-内存控制","link":"https://lz5z.com/深入浅出Node-js-内存控制/","description":"第五章 内存控制 本章学习 V8 的垃圾回收机制以及如何高效使用内存，内存泄漏以及如何排查内存泄漏。 V8 的垃圾回收机制与内存限制 关于 JavaScript 中常用的垃圾回收机制，可以参考这篇文章 JavaScript 垃圾回收。 V8 的内存限制 一般后端开发语言中，在基本的内存使用上都没有什么限制，而 Node 中将 JavaScript 的使用内存做出如下限制：64 位操作系统约为 1.4G，32 位操作系统约为 0.7G。在这样的限制下，Node 无法直接操作大内存对象，比如将一个 2GB 文件读取到内存中进行字符串分析，即使物理内存有 32 GB。 V8 的对象分配 在 V8 中，所有的 JavaScript 对象都是通过堆来进行内存分配的，Node 中可以通过 process.memoryUsage() 查看内存使用情况。 123456$ node&gt; process.memoryUsage()&gt; &#123; rss: 24244224, heapTotal: 9232384, heapUsed: 5041608, external: 11497 &#125;","pubDate":"Sun, 27 May 2018 21:14:20 GMT","guid":"https://lz5z.com/深入浅出Node-js-内存控制/","category":"Node"},{"title":"《深入浅出Node.js》-异步I/O","link":"https://lz5z.com/深入浅出Node-js-异步I-O/","description":"第三章 异步 I/O 异步的概念首先在 Web2.0 中火起来，是因为浏览器中 JavaScript 在单线程上执行，而且它还与 UI 渲染共用一个线程。这意味着 JavaScript 在执行的时候 UI 渲染和响应是处于停滞状态的。前端通过异步的方式来消除 UI 阻塞的现象。假如业务场景中有一组互不相关的任务需要完成，可以采用下面两种方式。 单线程串行一次执行。 多线程并行执行。 如果创建多线程的开销小于并行执行，那么多线程的方式是首选的。多线程的代价在于创建线程和执行期间线程上下文切换的开销较大。另外，在复杂业务中，多线程编程经常面临锁、状态同步等问题。但是多线程能有效利用 CPU。 单线程顺序执行比较符合编程人员按照顺序思考的思维方式，也是最主流的编程方式。缺点在于执行性能，任何一个略慢的任务都会导致后续执行代码被阻塞。 Node 在两者之间给出了它的方案：利用单线程，远离多线程死锁，状态同步问题；利用异步 I/O，让单线程远离阻塞，更好地利用 CPU。 异步 I/O 就是 I/O 的调用不再阻塞后续计算，将原有等待 I/O 完成这段时间分配给其它需要的业务去执行。","pubDate":"Fri, 25 May 2018 22:20:38 GMT","guid":"https://lz5z.com/深入浅出Node-js-异步I-O/","category":"Node"},{"title":"《深入浅出Node.js》-读书笔记","link":"https://lz5z.com/深入浅出Node-js-读书笔记/","description":"简介 不知不觉 Node 已经更新到第十个版本了，本人使用 Node 也有两年多时间，之前学习的东西一直零零散散，没有形成系统的知识体系，于是最近又抽时间回顾这本经典的 《深入浅出Node.js》，阅读的过程中，难免有些东西不易理解或者容易忘记，因此选择博客的形式记录。 作者书写这本书的时候，Node 的稳定版本为 v0.10.13，当前最高版本为 v10.1.0，不过整个 Node 的核心体系在当时已经形成，因此对更高版本的理解问题不大。 第一章 Node 简介 Node 诞生于 2009 年 3 月，作者为 Ryan Dahl。作者选择 JavaScript 作为 Node 的实现语言主要因为：JavaScript 高性能（V8），符合事件驱动，没有后端历史包袱。 除了 HTML、WebKit 和显卡这些与 UI 相关技术没有支持外，整个 Node 的结构与 Chrome 非常相似，它们都是基于事件驱动的异步架构，浏览器通过事件驱动来服务界面上的交互，Node 通过事件驱动来服务 I/O。","pubDate":"Wed, 23 May 2018 22:51:15 GMT","guid":"https://lz5z.com/深入浅出Node-js-读书笔记/","category":"Node"},{"title":"HTTPS 加密原理","link":"https://lz5z.com/HTTPS加密原理/","description":"前面几天学习 DNS 缓存的时候，了解到了 DNS 劫持和 HTTP 劫持，关于 DNS 劫持和 HTTP 劫持的区别，知乎上一位同学给出了有趣的比喻DNS劫持和HTTP劫持有什么区别？: DNS 劫持：你输入的网址是 http://www.google.com，出来的是百度的页面。 HTTP 劫持：你打开的是知乎的页面，右下角弹出唐老师的不孕不育广告（2018年更：右下角弹出：偶系渣渣辉）。 应对 HTTP 劫持最有效的方法就是 HTTPS。本文学习 HTTPS 相关的知识。在学习之前首先抛出三个问题： HTTPS 加密原理是什么？ HTTPS 是否安全？为什么？ 为什么抓包工具比如 Fiddler/Charles 能抓取 HTTPS 协议的包？","pubDate":"Tue, 22 May 2018 21:05:58 GMT","guid":"https://lz5z.com/HTTPS加密原理/","category":"网络"},{"title":"Web 性能优化-首屏和白屏时间","link":"https://lz5z.com/Web性能优化-首屏和白屏时间/","description":"什么是首屏和白屏时间？ 白屏时间是指浏览器从响应用户输入网址地址，到浏览器开始显示内容的时间。 首屏时间是指浏览器从响应用户输入网络地址，到首屏内容渲染完成的时间。 白屏时间 = 地址栏输入网址后回车 - 浏览器出现第一个元素 首屏时间 = 地址栏输入网址后回车 - 浏览器第一屏渲染完成 影响白屏时间的因素：网络，服务端性能，前端页面结构设计。 影响首屏时间的因素：白屏时间，资源下载执行时间。 以百度为例，将 chrome 网速调为 Fast 3G，然后打开 Performance 工具，点击 “Start profiling and reload page” 按钮，查看 Screenshots 如下图：","pubDate":"Thu, 17 May 2018 19:24:09 GMT","guid":"https://lz5z.com/Web性能优化-首屏和白屏时间/","category":"性能"},{"title":"Web 性能优化-缓存-HTTP 缓存","link":"https://lz5z.com/Web性能优化-HTTP缓存/","description":"浏览器缓存 HTTP 缓存通常要配合客户端（浏览器）使用才能发挥效果，所以又被称之为浏览器缓存，是 Web 性能优化的一大利器。 缓存类型 浏览器缓存分为强缓存和协商缓存。 (1) 强缓存：浏览器在加载资源的时候，根据资源的 HTTP Header 判断它是否命中强缓存，如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。 (2) 协商缓存：当强缓存没有命中的时候，浏览器向服务器发送请求，服务器端依据资源的另外一些 HTTP Header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回 304，浏览器从缓存中加载这个资源；若未命中请求，服务端返回 200 并将资源返回客户端，浏览器更新本地缓存数据。","pubDate":"Wed, 16 May 2018 16:39:55 GMT","guid":"https://lz5z.com/Web性能优化-HTTP缓存/","category":"性能"},{"title":"Web 性能优化-缓存-DNS 缓存","link":"https://lz5z.com/Web性能优化-DNS缓存/","description":"缓存梗概 缓存技术几乎存在于网络技术发展的各个角落，从数据库到服务器，从服务器到网络，再从网络到客户端，缓存随处可见。跟前端有关的缓存技术主要有：DNS 缓存，HTTP 缓存，浏览器缓存，HTML5 缓存（localhost/manifest）和 service worker 中的 cache api。 DNS 缓存 当用户在浏览器中输入网址的地址后，浏览器要做的第一件事就是解析 DNS： (1) 浏览器检查缓存中是否有域名对应的 IP，如果有就结束 DNS 解析过程。浏览器中的 DNS 缓存有时间和大小双重限制，时间一般为几分钟到几个小时不等。DNS 缓存时间过长会导致如果 IP 地址发生变化，无法解析到正确的 IP 地址；时间过短会导致浏览器重复解析域名。 (2) 如果浏览器缓存中没有对应的 IP 地址，浏览器会继续查找操作系统缓存中是否有域名对应的 DNS 解析结果。我们可以通过在操作系统中设置 hosts 文件来设置 IP 与域名的关系。","pubDate":"Wed, 16 May 2018 13:32:17 GMT","guid":"https://lz5z.com/Web性能优化-DNS缓存/","category":"性能"},{"title":"Web 性能优化-CSS3 硬件加速(GPU 加速)","link":"https://lz5z.com/Web性能优化-CSS3硬件加速/","description":"CSS3 硬件加速简介 上一篇文章学习了重绘和回流对页面性能的影响，是从比较宏观的角度去优化 Web 性能，本篇文章从每一帧的微观角度进行分析，来学习 CSS3 硬件加速的知识。 CSS3 硬件加速又叫做 GPU 加速，是利用 GPU 进行渲染，减少 CPU 操作的一种优化方案。由于 GPU 中的 transform 等 CSS 属性不会触发 repaint，所以能大大提高网页的性能。 我做了一个页面，左边元素的动画通过 left/top 操作位置实现，右边元素的动画通过 transform: translate 实现，你可以打开 chrome 的 “Paint flashing” 查看，绿色部分是正在 repaint 的内容。 查看地址 从 demo 中可以看到左边的图形在运动时外层有一圈绿色的边框，表示元素不停地 repaint，并且可以看到其运动过程中有丢帧现象，具体表现为运动不连贯，有轻微闪动。","pubDate":"Thu, 03 May 2018 20:10:40 GMT","guid":"https://lz5z.com/Web性能优化-CSS3硬件加速/","category":"性能"},{"title":"Web 性能优化-页面重绘和回流（重排）","link":"https://lz5z.com/Web性能优化-页面重绘和回流/","description":"前言 早在五年前，Google 就提出了 1s 完成终端页面的首屏渲染的标准。 常见的优化网络请求的方法有：DNS Lookup，减少重定向，避免 JS、CSS 阻塞，并行请求，代码压缩，缓存，按需加载，前端模块化…","pubDate":"Wed, 02 May 2018 21:46:24 GMT","guid":"https://lz5z.com/Web性能优化-页面重绘和回流/","category":"性能"}]}